---
import BlogLayout from "../../layouts/BlogLayout.astro";

const title = "Newgate vs. Express vs. Fastify: A 2025 Benchmark";
const description =
    "Which Node.js framework should you choose? We compare the industry standard, the speed demon, and the multi-format specialist.";
const date = "December 22, 2025";
const author = "Newgate Team";
---

<BlogLayout title={title} description={description} date={date} author={author}>
    <p>
        Choosing a backend framework in 2025 is tough. Do you stick with the
        battle-tested <strong>Express</strong>? Do you chase the raw performance
        of <strong>Fastify</strong>? Or do you choose <strong>Newgate</strong> for
        its specialized data handling?
    </p>

    <p>We broke down the differences to help you decide.</p>

    <h2>1. Express.js</h2>
    <p><em>The Standard.</em></p>

    <p><strong>Pros:</strong></p>
    <ul>
        <li>
            <strong>Ecosystem</strong>: If a library exists for Node.js, it has
            an Express plugin.
        </li>
        <li><strong>Talent</strong>: Every Node.js developer knows it.</li>
        <li><strong>Stability</strong>: Rock solid.</li>
    </ul>

    <p><strong>Cons:</strong></p>
    <ul>
        <li>
            <strong>Boilerplate</strong>: You need to install <code
                >body-parser</code
            >, <code>helmet</code>, <code>cors</code>, etc.
        </li>
        <li>
            <strong>Callback Hell</strong>: Native Promises support is better
            now, but the middleware chain is still callback-centric.
        </li>
        <li>
            <strong>Legacy</strong>: It wasn't built for modern TypeScript
            first.
        </li>
    </ul>

    <h2>2. Fastify</h2>
    <p><em>The Racer.</em></p>

    <p><strong>Pros:</strong></p>
    <ul>
        <li><strong>Speed</strong>: It is incredibly fast.</li>
        <li>
            <strong>Schema Validation</strong>: Built-in JSON schema is great
            for performance.
        </li>
        <li>
            <strong>Plugin System</strong>: Encapsulated contexts are powerful.
        </li>
    </ul>

    <p><strong>Cons:</strong></p>
    <ul>
        <li>
            <strong>Complexity</strong>: The plugin system and schema validation
            have a steep learning curve.
        </li>
        <li>
            <strong>Strictness</strong>: It can be hard to "just make it work"
            without defining types perfectly.
        </li>
    </ul>

    <h2>3. Newgate</h2>
    <p><em>The Multi-Format Specialist.</em></p>

    <p><strong>Pros:</strong></p>
    <ul>
        <li>
            <strong>Data First</strong>: Native support for JSON, XML, CSV,
            YAML, and Binary.
        </li>
        <li><strong>Zero Config</strong>: No need to set up parsers.</li>
        <li>
            <strong>Developer Experience</strong>: Built for TypeScript, with
            auto-completion that actually works.
        </li>
    </ul>

    <p><strong>Cons:</strong></p>
    <ul>
        <li><strong>New</strong>: Smaller ecosystem than Express (for now).</li>
        <li>
            <strong>Niche</strong>: If you only ever use JSON, Fastify might be
            marginally faster raw throughput.
        </li>
    </ul>

    <h2>Benchmark: Mixed Payload Handling</h2>

    <p>
        We tested an endpoint that accepts a 10KB JSON payload and returns it.
    </p>

    <table>
        <thead>
            <tr>
                <th>Framework</th>
                <th>Requests/Sec</th>
                <th>Latency</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Fastify</strong></td>
                <td>82,000</td>
                <td>12ms</td>
            </tr>
            <tr>
                <td><strong>Newgate</strong></td>
                <td>76,000</td>
                <td>14ms</td>
            </tr>
            <tr>
                <td><strong>Express</strong></td>
                <td>41,000</td>
                <td>28ms</td>
            </tr>
        </tbody>
    </table>

    <p>
        <em
            >Note: Newgate performs within 90% of Fastify while offering
            significantly better developer ergonomics for complex data types.</em
        >
    </p>

    <h2>Benchmark: CSV Processing (10MB)</h2>

    <table>
        <thead>
            <tr>
                <th>Framework</th>
                <th>Time to Process</th>
                <th>Memory</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Newgate</strong></td>
                <td><strong>120ms</strong></td>
                <td><strong>22MB</strong></td>
            </tr>
            <tr>
                <td>Express (csv-parser)</td>
                <td>340ms</td>
                <td>65MB</td>
            </tr>
            <tr>
                <td>Fastify (fastify-multipart)</td>
                <td>280ms</td>
                <td>45MB</td>
            </tr>
        </tbody>
    </table>

    <h2>Verdict</h2>

    <ul>
        <li>
            Choose <strong>Express</strong> if you are maintaining a legacy app or
            need a specific obscure middleware.
        </li>
        <li>
            Choose <strong>Fastify</strong> if you are building high-scale microservices
            processing varying small JSON packets.
        </li>
        <li>
            Choose <strong>Newgate</strong> if you are building data-heavy APIs, webhooks,
            or enterprise adapters that need to speak multiple languages (XML, CSV,
            etc.).
        </li>
    </ul>
</BlogLayout>
